La complexité, dans le meilleur des cas est de O(1), insertionSort n'effectue aucune comparaison car le tableau est déjà trié.Dans le pire des cas, quand le tableau doit être totalement inversé, la complexité est de O(n2).L'algorithme est adaptatif, on voit bien qu'il y a moins de comparaisons pour trier tab1 que tab2.La complexité spatiale est O(1), on effectue seulement des échanges dans le tableau, sans utiliser d'espaces supplémentaires.L'algortihme est stable, en effet, on n'entre pas dans la condition du while lorsque les valeurs sont égales, ainsi elles n'échangent pas de place.

En faisant int* tmp = tab, on définit comme tmp comme un pointeur vers le premier élément de tab, ainsi, si on modifie des éléments de tmp, on va modifier les éléments de tab : on ne va pas créer de nouveau tableau.En faisant int tmp[n], le programme ne va pas compiler, on ne peut pas définir un tableau avec une variable comme n.On utilisera int* tmp = malloc(n * sizeof(int)).

La complexité, dans le meilleur des cas est de O(n2), bubbleSort effectue des comparaisons entre tous les chiffres du tableau même s'il est déjà trié.Dans le pire des cas, quand le tableau doit être totalement inversé, la complexité est de O(n2), il compare encore tous les chiffres du tableau.L'algorithme n'est pas adaptatif, on voit bien qu'il y a toujours autant de comparaisons effectuées.La complexité spatiale est O(1), on effectue seulement des échanges dans le tableau, sans utiliser d'espaces supplémentaires.L'algorithme est stable, en effet, on n'entre pas dans le if lorsque les valeurs sont égales, ainsi elles n'échangent pas de place.

Le meilleur des cas testés est celui pour lequel le tableau est totalement inversé, il y a moins de comparaisons que pour un tableau déjà trié.La complexité temporelle est de O(n*log(n)) car on réalise l'itération globale de l'ordre de log n fois. Dans cette itération, on traite deux sous-tableaux de n/2 éléments.D'où une complexité de O(log(n)*2*(n/2))=O(n*log(n)).La complexité spatiale est O(n) car, au maximum, l'on crée deux tableaux temporaires de taille n/2 soit n éléments stockés temporairement.L'algortihme est stable d'après la condition du premier while dans merge qui inclus le cas où deux valeurs sont égales
